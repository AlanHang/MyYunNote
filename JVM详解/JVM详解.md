[TOC]

# 1. JVM和Java体系架构

##  1.1 JVM所处位置

JVM（程序虚拟机）是运行在操作系统之上的，它与硬件没有直接的交互。

![image-20210222192810177](JVM详解.assets/image-20210222192810177.png)

![image-20210222192839539](JVM详解.assets/image-20210222192839539.png)

## 1.2 JVM整体结构

HotSpot VM 采用解释器与即时编译器并存的架构。

![image-20210218144600799](JVM详解.assets/image-20210218144600799.png)

![image-20210223200739276](JVM详解.assets/image-20210223200739276.png)

##  1.3 Java代码执行流程

![image-20210222194046834](JVM详解.assets/image-20210222194046834.png)

## 1.4 JVM的结构模型

Java 编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。

具体来说，两种架构之间的区别：

- 基于栈示架构的特点
  - 设计和实现更简单，适用于资源受限的系统。
  - 避开了寄存器的分配难题：使用零地址指令方式分配。
  - 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。
  - 不需要硬件支持，可移植性更好，更好实现跨平台。
- 基于寄存器架构的特点
  - 典型的应用是X86的二进制指令集：比如传统的PC以及安卓的Davlik虚拟机。
  - 指令集架构则完全依赖硬件，可移植性差。
  - 性能优秀、执行更高效。
  - 花费更少的指令去完成一项操作。
  - 大部分情况下，基于寄存器架构的指令集往往都以一地址指令，二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址为主。

```
Java 反编译命令 javap -v xxx.class
```

## 1.5 JVM的生命周期

**JVM虚拟机启动**

Java虚拟机的启动时通过引导类加载器（bootstrap class loader ）创建的一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。

**虚拟机的执行**

- 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。
- 程序开始执行时他才运行，程序结束时他就停止。
- ==执行一个所谓的Java程序的时候，真真正正在执行的是一个叫Java虚拟机的进程。==

**虚拟机的退出**

有如下几种情况：

- 程序正常执行结束。
- 程序在执行过程中遇到了异常或错误而异常终止。
- 由于操作系统出现错误而导致Java虚拟机进程终止。
- 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或者halt操作。
- 除此之外，JNI规范中描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机退出的情况。

## 1.6 虚拟机发展史

**Sun Classic VM**

![image-20210223192227313](JVM详解.assets/image-20210223192227313.png)

**Exact VM**

![image-20210223192249005](JVM详解.assets/image-20210223192249005.png)

**HotSpot VM**

![image-20210223192420990](JVM详解.assets/image-20210223192420990.png)

**JRockit**

![image-20210223192645086](JVM详解.assets/image-20210223192645086.png)

**J9**

![image-20210223193021123](JVM详解.assets/image-20210223193021123.png)

# 2.类加载子系统（Class Loader System）

**类加载器子系统作用**

![image-20210223201122041.png](JVM详解.assets/image-20210223201122041.png)

**类加载器的角色**

![image-20210223201543571](JVM详解.assets/image-20210223201543571.png)

## 2.1 加载(loading)

加载：

1. 通过一个类的全限定名获取定义此类的二进制字节流。
2. 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构。
3. 在==内存中生成一个代表这个类的java.lang.Class对象==，作为方法区中这个类的各种参数的访问入口。

加载.class文件的方式：

- 从本地系统中直接加载
- 通过网络获取，典型场景:Web Applet
- 从zip压缩包中读取，成为日后jar、war格式的基础
- 运行时计算生成，使用最多的是：动态代理技术
- 由其他文件生成，典型场景：JSP应用
- 从专有数据库中提取.class文件，比较少见
- 从加密文件中获取，典型的防Class文件被反编译的保护措施

## 2.2 链接（Linking)

链接阶段：

1. 验证（Verity)
   - 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。
   - 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。

2. 准备（Prepare)

   - 为类变量分配内存并设置该类变量的默认初始值，即零值。

     >默认初始值 数字类型 整型为0，浮点型为0.0 char类型为\u0000,布尔类型为false, 引用类型为null。

   - 这里不包含用final修饰的static，因为final在编译时就会分配，准备阶段会显式初始化。

   - 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。

3. 解析（Resolve）
   - 将常量池内的符号引用转换为直接引用的过程。
   - 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。
   - 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
   - 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Filederf_info、CONSTANT_Methodref_info等。

## 2.3 初始化（initialization）

初始化：

- 初始化阶段就是执行类构造器方法<clinit>()的过程。
- 此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。
- 构造器方法中指令按语句在源文件中出现的顺序执行。
- <clinit>()不同于类的构造器。（关联：构造器是虚拟机视角下的<init>()）
- 若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕。
- 虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁。

![image-20210224200319270](JVM详解.assets/image-20210224200319270.png)

## 2.4 类加载器的分类

- JVM 支持两种类型的加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。
- 从概念上来讲，自定义加载器一般指的是程序中由开发人员自定义的一类加载器，但是Java虚拟机规范却没有这么定义，而是==将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。==
- Extension ClassLoader 和 System ClassLoader 继承自  URLClassLoader

![image-20210225142945976](JVM详解.assets/image-20210225142945976.png)

### 2.4.1 启动类加载器

启动类加载器（引导类加载器，Bootstrap ClassLoader）

- 这个类加载使用C/C++语言实现的，嵌套在JVM内部。
- 它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resource.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类。
- 并不继承自java.lang.ClassLoader，没有上层加载器。
- 加载扩展类和应用程序类加载器，并指定为他们的上层加载器。
- 出于安全考虑，Bootstrap启动类加载器只加载包名为java，javax，sun等开头的类。

![image-20210225193856604](JVM详解.assets/image-20210225193856604.png)

![image-20210225193825888](JVM详解.assets/image-20210225193825888.png)

### 2.4.2 扩展类加载器

扩展类加载器（Extension ClassLoader）

- Java 语言编写，由sun.misc.Launcher$ExtClassLoader实现。
- 派生于ClassLoader类。
- 上层加载器为启动类加载器。
- 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。

![image-20210225194252668](JVM详解.assets/image-20210225194252668.png)

### 2.4.3 应用程序类加载器

应用程序类加载器（系统类加载器，AppClassLoader）

- Java语言编写，由sun.misc.Launcher$AppClassLoader实现。
- 派生于ClassLoader类。
- 上层加载器为扩展类加载器
- 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库。
- 该类加载是程序中默认的类加载器，一般来说，Java应用类都是由它来完成加载。
- 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。

## 2.5 用户自定义类加载器

为什么要自定义类加载器：

- 隔离加载类
- 修改类加载的方式
- 扩展加载源
- 防止源码泄漏

![image-20210225195033227](JVM详解.assets/image-20210225195033227.png)

## 2.6 双亲委派机制

![image-20210225195810136](JVM详解.assets/image-20210225195810136.png)

![image-20210225195951648](JVM详解.assets/image-20210225195951648.png)

优势：

- 避免类的重复加载
- 保护程序安全，防止核心API被篡改。

